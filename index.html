<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Para el amor de mi vida</title>
    <style>
        :root {
            --bg-color: #f5ede3;
            --text-color: #4a4a4a;
            --heart-red: #d63447;
        }

        body {
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            color: var(--text-color);
        }

        /* Contenedor principal */
        .container {
            text-align: left;
            width: 80%;
            max-width: 600px;
            position: relative;
            z-index: 100; /* siempre al frente del √°rbol */
            pointer-events: auto;
        }

        h2 { 
            font-weight: 600; 
            margin-bottom: 10px;
            text-shadow: 0 1px 3px rgba(255, 255, 255, 0.8);
        }
        p { 
            font-style: italic; 
            font-size: 1.2rem; 
            line-height: 1.6;
            font-weight: 500;
            text-shadow: 0 1px 3px rgba(255, 255, 255, 0.8);
        }

        /* Estilo del contador */
        .timer {
            margin-top: 50px;
            font-size: 0.9rem;
        }
        #counter {
            font-weight: bold;
            display: block;
            font-size: 1.1rem;
        }

        /* El √Årbol */
        .tree-container {
            position: absolute;
            right: 8%;
            bottom: 6%;
            width: 420px; /* m√°s ancho */
            height: 560px; /* m√°s alto */
            z-index: 5; /* asegurar por encima de texto */
            overflow: visible;
        }

        .trunk {
            position: absolute;
            bottom: 0;
            left: 50%;
            width: 20px;
            height: 0;
            background: #5d4037;
            transform: translateX(-50%);
            animation: growTrunk 2s forwards ease-out;
        }

        @keyframes growTrunk {
            to { height: 250px; }
        }

        /* Corazones/Hojas */
        .heart {
            position: absolute;
            color: var(--heart-red);
            font-size: 20px;
            opacity: 0;
            animation: fadeInHeart 1s forwards, floatHeart 4s ease-in-out infinite;
            display: block;
        }

        @keyframes fadeInHeart {
            to { opacity: 0.8; transform: translateY(-10px); }
        }

        /* reveal chars */
        .char { opacity: 0; display: inline-block; transform: translateY(6px); transition: opacity 320ms ease, transform 320ms ease; }

        @keyframes floatHeart {
            0% { transform: translateY(0) rotate(-6deg); }
            50% { transform: translateY(-6px) rotate(6deg); }
            100% { transform: translateY(0) rotate(-6deg); }
        }

          /* audio: intentamos reproducir sin interacci√≥n; si el navegador lo bloquea mantendremos reproducci√≥n en mute
              (no se muestra ning√∫n bot√≥n invasivo para el usuario). Si falla, mostramos un control discreto en la esquina
              para diagn√≥stico y para permitir activar sonido manualmente. */

          /* audio control (discreto) */
          .audio-control {
                position: fixed;
                left: 12px;
                bottom: 12px;
                z-index: 80;
                display: flex;
                gap: 8px;
                align-items: center;
                background: rgba(255,255,255,0.9);
                padding: 6px 8px;
                border-radius: 999px;
                box-shadow: 0 6px 18px rgba(0,0,0,0.12);
                font-size: 0.9rem;
                color: #333;
          }
          .audio-toggle { background: none; border: none; cursor: pointer; font-size: 1.1rem; }
          .audio-status { font-size: 0.85rem; }

        /* start overlay */
        .start-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            /* cubrir totalmente y ocultar el contenido detr√°s: fondo opaco igual al fondo de la p√°gina */
            background: var(--bg-color);
            z-index: 120;
        }
        .start-button {
            background: #fff;
            border: none;
            border-radius: 10px;
            padding: 16px 24px;
            font-size: 1.1rem;
            cursor: pointer;
            box-shadow: 0 8px 28px rgba(0,0,0,0.28);
        }

    </style>
</head>
<body>

    <div id="start-overlay" class="start-overlay">
        <button id="start-button" class="start-button">Iniciar</button>
    </div>

    <div class="container" style="visibility:hidden;">
        <h2>Para Agus:</h2>
        <p id="phrase1">Si pudiera elegir un lugar seguro, no deberia pensarlo porque ya lo tengo con vos.</p>
        <p id="phrase2">Cuanto m√°s tiempo estoy con vos, m√°s te amo.</p>
        
        <div class="timer">
            Mi amor por vos comenz√≥ hace...
            <span id="counter">Cargando tiempo...</span>
        </div>
    </div>

    <!-- audio de fondo: pon aqu√≠ tu archivo MP3 en el root y ren√≥mbralo a `background.mp3` o ajusta el src -->
    <audio id="bg-music" src="background.mp3" preload="auto" loop></audio>

    <!-- estado / control de audio (se muestra solo si es necesario) -->
    <div id="audio-control" style="display:none" aria-hidden="true" class="audio-control">
        <button id="audio-toggle" class="audio-toggle" title="Activar / desactivar sonido">üîà</button>
        <div id="audio-status" class="audio-status">audio: inicializando...</div>
    </div>

    <div class="tree-container" id="tree" style="visibility:hidden;">
        <div class="trunk"></div>
    </div>

    <script>
        // --- CONFIGURACI√ìN ---
        // Pon aqu√≠ la fecha en que empezaron (A√±o, Mes - 1, D√≠a, Hora, Minuto)
        // Ejemplo: 22 de febrero de 2025 a las 13:36
        const startDate = new Date(2019, 3, 3, 15, 0, 0); 

    // --- CONTADOR ---
        function updateTimer() {
            const now = new Date();
            const diff = now - startDate;

            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diff / (1000 * 60 * 60)) % 24);
            const minutes = Math.floor((diff / 1000 / 60) % 60);
            const seconds = Math.floor((diff / 1000) % 60);

            document.getElementById('counter').innerText = 
                `${days} d√≠as ${hours} horas ${minutes} minutos ${seconds} segundos`;
        }

        // Timer won't start until the user clicks "Iniciar". We'll start it from startEverything().
        let _timerInterval = null;
        function startTimer() {
            if (_timerInterval) return;
            updateTimer();
            _timerInterval = setInterval(updateTimer, 1000);
        }

        // --- √ÅRBOL DE CORAZONES ---
        const tree = document.getElementById('tree');
        const heartColors = ['#ff4d6d', '#ff758f', '#c9184a', '#ffb3c1', '#a4133c'];
    // inputs (pueden no existir en todas las versiones); definirlos evita errores
    const spawnDelayInput = document.getElementById('spawnDelay');
    const floatSpeedInput = document.getElementById('floatSpeed');

        // reveal text function (letra a letra) - preserve spaces correctly
        function revealText(element, perChar = 30, startDelay = 200) {
            if (!element) return;
            // cancel any previous reveal on this element
            if (element._revealInterval) {
                clearInterval(element._revealInterval);
                element._revealInterval = null;
            }
            const text = (element.textContent || '');
            element.innerHTML = '';
            const chars = [];
            for (const ch of text) {
                const span = document.createElement('span');
                span.className = 'char';
                // preserve spaces as non-breaking spaces so inline-block spans keep word gaps
                span.textContent = (ch === ' ') ? '\u00A0' : ch;
                element.appendChild(span);
                chars.push(span);
            }
            let i = 0;
            const iv = setInterval(() => {
                if (i >= chars.length) {
                    clearInterval(iv);
                    element._revealInterval = null;
                    return;
                }
                const span = chars[i];
                span.style.opacity = '1';
                span.style.transform = 'translateY(0)';
                i++;
            }, perChar);
            element._revealInterval = iv;
            // allow an initial delay before starting
            if (startDelay > 0) {
                // pause the interval until delay passes
                clearInterval(iv);
                element._revealInterval = setTimeout(() => {
                    element._revealInterval = setInterval(() => {
                        if (i >= chars.length) {
                            clearInterval(element._revealInterval);
                            element._revealInterval = null;
                            return;
                        }
                        const span = chars[i];
                        span.style.opacity = '1';
                        span.style.transform = 'translateY(0)';
                        i++;
                    }, perChar);
                }, startDelay);
            }
        }

        function createHeart() {
            const total = 320; // m√°s corazones para una copa m√°s densa
            const baseDelay = parseInt(spawnDelayInput ? spawnDelayInput.value : 100, 10) || 100;
            // calcular dimensiones robustamente: clientWidth/Height o computed style fallback
            let TW = tree.clientWidth;
            let TH = tree.clientHeight;
            if (!TW || !TH) {
                const cs = getComputedStyle(tree);
                TW = parseFloat(cs.width) || 420;
                TH = parseFloat(cs.height) || 560;
            }
            const centerX = TW / 2;
            const centerY = TH / 2;
            console.log('createHeart() container size', TW, TH, 'baseDelay', baseDelay);
            for (let i = 0; i < total; i++) {
                setTimeout(() => {
                    const heart = document.createElement('div');
                    heart.innerHTML = '‚ù§';
                    heart.className = 'heart';

                    // Posiciones aleatorias para formar la copa del √°rbol (forma de coraz√≥n)
                    const t = Math.random() * Math.PI * 2;
                    const r = Math.random() * (Math.min(TW, TH) / 3); // escala relativa al contenedor
                    // polar to cartesian with a bias to create heart-like cluster
                    let x = centerX + (r * Math.sin(t) * (1 + 0.6 * Math.sin(3 * t)));
                    let y = centerY + (r * Math.cos(t) * (1 + 0.4 * Math.cos(2 * t)));

                    // jitter
                    x += (Math.random() - 0.5) * (TW * 0.08);
                    y += (Math.random() - 0.5) * (TH * 0.08);

                    // asegurar dentro de caja
                    const left = Math.max(0, Math.min(TW - 20, x));
                    const bottom = Math.max(0, Math.min(TH - 20, TH - y));

                    heart.style.left = left + 'px';
                    heart.style.bottom = bottom + 'px';
                    heart.style.color = heartColors[Math.floor(Math.random() * heartColors.length)];
                    heart.style.fontSize = (Math.random() * 20 + 10) + 'px';

                    // controlar duraci√≥n del float con control
                    const floatSec = (floatSpeedInput ? floatSpeedInput.value : 4);
                    const dur = (parseFloat(floatSec) + (Math.random() - 0.5) * 1.5).toFixed(2);
                    heart.style.animationDuration = `1s, ${dur}s`;

                    tree.appendChild(heart);
                }, i * baseDelay);
            }
        }

        // A√±adir m√°s corazones alrededor del tronco (base)
        function createTrunkHearts() {
            const trunkCount = 120; // m√°s corazones en la zona del tronco
            // calcular referencia al centro del contenedor
            let TW = tree.clientWidth || 420;
            let TH = tree.clientHeight || 560;
            if (!TW || !TH) { const cs = getComputedStyle(tree); TW = parseFloat(cs.width)||TW||420; TH = parseFloat(cs.height)||TH||560; }
            const centerX = TW / 2;
            // colocar corazones cerca de la base (y bajo la mitad)
            for (let i = 0; i < trunkCount; i++) {
                setTimeout(() => {
                    const h = document.createElement('div');
                    h.className = 'heart';
                    h.innerHTML = '‚ù§';
                    // posici√≥n cerca del tronco (centro) con un peque√±o desplazamiento
                    const x = centerX + (Math.random() - 0.5) * 40; // ¬±20px
                    const bottom = Math.random() * 80; // dentro de 0..80px desde la base
                    h.style.left = Math.max(0, Math.min(TW - 20, x)) + 'px';
                    h.style.bottom = bottom + 'px';
                    h.style.fontSize = (Math.random() * 14 + 8) + 'px';
                    h.style.color = heartColors[Math.floor(Math.random() * heartColors.length)];
                    // suavizar float duration
                    const floatSec = (floatSpeedInput ? floatSpeedInput.value : 4);
                    const dur = (parseFloat(floatSec) + (Math.random() - 0.5) * 1.2).toFixed(2);
                    h.style.animationDuration = `1s, ${dur}s`;
                    tree.appendChild(h);
                }, i * (spawnDelayInput ? parseInt(spawnDelayInput.value,10) : 100));
            }
        }

        // --- AUDIO DE FONDO ---
        const bgAudio = document.getElementById('bg-music');

        // small UI helpers for status/control
        const audioControl = document.getElementById('audio-control');
        const audioStatusEl = document.getElementById('audio-status');
        const audioToggle = document.getElementById('audio-toggle');

        function updateAudioStatus(msg) {
            try { if (audioStatusEl) audioStatusEl.textContent = `audio: ${msg}`; } catch (e) {}
            console.log('[audio]', msg);
        }

        function showAudioControl() {
            if (!audioControl) return;
            audioControl.style.display = 'flex';
            updateAudioToggle();
        }

        function updateAudioToggle() {
            if (!audioToggle || !bgAudio) return;
            audioToggle.textContent = bgAudio.muted ? 'üîá' : 'üîà';
        }

        audioToggle && audioToggle.addEventListener('click', async () => {
            if (!bgAudio) return;
            try {
                bgAudio.muted = !bgAudio.muted;
                if (bgAudio.paused) await bgAudio.play();
                updateAudioToggle();
                updateAudioStatus(bgAudio.muted ? 'silenciado manualmente' : 'sonando (manual)');
            } catch (e) {
                console.warn('Error al cambiar estado de audio:', e);
                updateAudioStatus('error al activar audio');
            }
        });

        // Fallback: intentar iniciar audio al PRIMER gesto del usuario en la p√°gina.
        // No es un bot√≥n visible espec√≠fico: cualquier interacci√≥n cuenta (click, tecla, touch, scroll).
        let _gestureHandlersAttached = false;
        function attachGestureStartListeners() {
            if (_gestureHandlersAttached) return;
            _gestureHandlersAttached = true;
            const oncePlay = async (ev) => {
                try {
                    // intentar reproducir con sonido (es el gesto del usuario)
                    bgAudio.muted = false;
                    bgAudio.volume = 0.6;
                    const p = bgAudio.play();
                    if (p && p instanceof Promise) await p;
                    updateAudioStatus('iniciada tras interacci√≥n del usuario');
                    updateAudioToggle();
                    detachGestureStartListeners();
                    // si todo ok, ocultar control si estaba visible
                    if (audioControl) audioControl.style.display = 'none';
                } catch (err) {
                    console.warn('No se pudo reproducir tras gesto del usuario:', err);
                    updateAudioStatus('no fue posible iniciar audio tras interacci√≥n');
                    // dejar el control visible para que pueda activarlo manualmente
                    showAudioControl();
                    detachGestureStartListeners();
                }
            };

            // eventos que consideramos gesto del usuario
            ['pointerdown', 'touchstart', 'keydown', 'scroll'].forEach((evName) => {
                window.addEventListener(evName, oncePlay, { once: true, passive: true });
            });
        }

        function detachGestureStartListeners() {
            // No-op: we used {once:true} so handlers are removed automatically.
            _gestureHandlersAttached = false;
        }

        // Intento de reproducci√≥n sin interacci√≥n:
        // 1) Intentar play() con sonido directamente.
        // 2) Si falla, reproducir en mute (la mayor√≠a de navegadores permiten autoplay si est√° muteado).
        // 3) Tras una peque√±a espera, intentar gradualmente subir el volumen y desmutear (best-effort).
        async function tryPlayBackground() {
            if (!bgAudio) return;
            bgAudio.loop = true;
            const targetVolume = 0.6;
            const rampDuration = 4000; // ms para subir el volumen

            // Helper: gradualmente ajustar volumen desde current hasta target
            function rampVolume(to, duration) {
                const from = bgAudio.volume;
                const steps = 30;
                const stepTime = Math.max(10, Math.floor(duration / steps));
                let step = 0;
                const iv = setInterval(() => {
                    step++;
                    const t = step / steps;
                    bgAudio.volume = from + (to - from) * t;
                    if (step >= steps) clearInterval(iv);
                }, stepTime);
            }

            try {
                bgAudio.muted = false;
                bgAudio.volume = targetVolume;
                const p = bgAudio.play();
                if (p && p instanceof Promise) await p;
                updateAudioStatus('iniciada con sonido');
                return;
            } catch (err) {
                console.warn('Autoplay con sonido bloqueado, intentando reproducir en mute:', err);
                updateAudioStatus('autoplay con sonido bloqueado, intentando mute');
            }

            // reproducir en mute (si autoplay con sonido fue bloqueado)
            try {
                bgAudio.muted = true;
                bgAudio.volume = 0;
                const p2 = bgAudio.play();
                if (p2 && p2 instanceof Promise) await p2;
                updateAudioStatus('reproducci√≥n en mute iniciada');
                // mostrar control discreto para permitir activar sonido manualmente si el navegador
                // impide desmutear autom√°ticamente
                showAudioControl();

                // despu√©s de un peque√±o retardo, intentar desmutear gradualmente
                setTimeout(async () => {
                    try {
                        // Desmutear y subir volumen gradualmente (best-effort). Algunos navegadores
                        // a√∫n pueden bloquear el cambio a sonido real; por eso lo hacemos en try/catch.
                        bgAudio.muted = false;
                        rampVolume(targetVolume, rampDuration);
                        updateAudioStatus('intentando subir volumen tras autoplay en mute');
                        // actualizar UI
                        updateAudioToggle();
                    } catch (e) {
                        console.warn('No fue posible desmutear autom√°ticamente:', e);
                        updateAudioStatus('no fue posible desmutear autom√°ticamente');
                        // dejar en mute si no es posible
                        bgAudio.muted = true;
                        showAudioControl();
                    }
                }, 800);

                return;
            } catch (err) {
                console.warn('No se pudo iniciar reproducci√≥n (incluso en mute):', err);
            }
        }

        // start everything when user clicks the start button (or interacts)
        function startEverything() {
            const overlay = document.getElementById('start-overlay');
            if (overlay) overlay.style.display = 'none';
            // mostrar contenido
            try { document.querySelector('.container').style.visibility = 'visible'; } catch(e){}
            try { document.getElementById('tree').style.visibility = 'visible'; } catch(e){}
            // start timer
            startTimer();
            // intentar iniciar la m√∫sica de fondo
            tryPlayBackground();
            // revelar texto
            revealText(document.querySelector('h2') || document.querySelector('h1'), 40, 200);
            revealText(document.getElementById('phrase1'), 18, 600);
            revealText(document.getElementById('phrase2'), 18, 1200);
            // crear corazones tras asegurar layout
            requestAnimationFrame(() => setTimeout(() => {
                createHeart();
                createTrunkHearts();
            }, 600));
            // hide the small audio control because the user explicitly started
            try { const ac = document.getElementById('audio-control'); if (ac) ac.style.display = 'none'; } catch(e){}
        }

        window.onload = () => {
            // attach start button
            const startBtn = document.getElementById('start-button');
            if (startBtn) startBtn.addEventListener('click', startEverything);
            // also allow any user gesture to start the experience (click anywhere, key, touch, scroll)
            ['pointerdown','touchstart','keydown','scroll'].forEach(ev => {
                window.addEventListener(ev, function onceStart() {
                    startEverything();
                    window.removeEventListener(ev, onceStart);
                }, { once: true, passive: true });
            });
        };
    </script>
</body>
</html>