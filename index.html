<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Para el amor de mi vida</title>
    <style>
        :root {
            --bg-color: #f5ede3;
            --text-color: #4a4a4a;
            --heart-red: #d63447;
        }

        body {
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            color: var(--text-color);
        }

        /* Contenedor principal */
        .container {
            text-align: left;
            width: 80%;
            max-width: 600px;
            z-index: 20; /* por encima del árbol para que no quede tapado */
            pointer-events: auto;
        }

        h2 { font-weight: 300; margin-bottom: 10px; }
        p { font-style: italic; font-size: 1.2rem; line-height: 1.6; }

        /* Estilo del contador */
        .timer {
            margin-top: 50px;
            font-size: 0.9rem;
        }
        #counter {
            font-weight: bold;
            display: block;
            font-size: 1.1rem;
        }

        /* El Árbol */
        .tree-container {
            position: absolute;
            right: 8%;
            bottom: 6%;
            width: 420px; /* más ancho */
            height: 560px; /* más alto */
            z-index: 5; /* asegurar por encima de texto */
            overflow: visible;
        }

        .trunk {
            position: absolute;
            bottom: 0;
            left: 50%;
            width: 20px;
            height: 0;
            background: #5d4037;
            transform: translateX(-50%);
            animation: growTrunk 2s forwards ease-out;
        }

        @keyframes growTrunk {
            to { height: 250px; }
        }

        /* Corazones/Hojas */
        .heart {
            position: absolute;
            color: var(--heart-red);
            font-size: 20px;
            opacity: 0;
            animation: fadeInHeart 1s forwards, floatHeart 4s ease-in-out infinite;
            display: block;
        }

        @keyframes fadeInHeart {
            to { opacity: 0.8; transform: translateY(-10px); }
        }

        /* reveal chars */
        .char { opacity: 0; display: inline-block; transform: translateY(6px); transition: opacity 320ms ease, transform 320ms ease; }

        @keyframes floatHeart {
            0% { transform: translateY(0) rotate(-6deg); }
            50% { transform: translateY(-6px) rotate(6deg); }
            100% { transform: translateY(0) rotate(-6deg); }
        }

        /* audio: intentamos reproducir sin interacción; si el navegador lo bloquea mantendremos reproducción en mute
           (no se muestra ningún botón para el usuario) */

    </style>
</head>
<body>

    <div class="container">
        <h2>Para el amor de mi vida:</h2>
        <p id="phrase1">Si pudiera elegir un lugar seguro, sería a tu lado.</p>
        <p id="phrase2">Cuanto más tiempo estoy contigo más te amo.</p>
        
        <div class="timer">
            Mi amor por ti comenzó hace...
            <span id="counter">Cargando tiempo...</span>
        </div>
    </div>

    <!-- audio de fondo: pon aquí tu archivo MP3 en el root y renómbralo a `background.mp3` o ajusta el src -->
    <audio id="bg-music" src="background.mp3" preload="auto" loop></audio>

    <div class="tree-container" id="tree">
        <div class="trunk"></div>
    </div>

    <script>
        // --- CONFIGURACIÓN ---
        // Pon aquí la fecha en que empezaron (Año, Mes - 1, Día, Hora, Minuto)
        // Ejemplo: 22 de febrero de 2025 a las 13:36
        const startDate = new Date(2019, 3, 3, 15, 0, 0); 

        // --- CONTADOR ---
        function updateTimer() {
            const now = new Date();
            const diff = now - startDate;

            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diff / (1000 * 60 * 60)) % 24);
            const minutes = Math.floor((diff / 1000 / 60) % 60);
            const seconds = Math.floor((diff / 1000) % 60);

            document.getElementById('counter').innerText = 
                `${days} días ${hours} horas ${minutes} minutos ${seconds} segundos`;
        }

        setInterval(updateTimer, 1000);

        // --- ÁRBOL DE CORAZONES ---
        const tree = document.getElementById('tree');
        const heartColors = ['#ff4d6d', '#ff758f', '#c9184a', '#ffb3c1', '#a4133c'];
    // inputs (pueden no existir en todas las versiones); definirlos evita errores
    const spawnDelayInput = document.getElementById('spawnDelay');
    const floatSpeedInput = document.getElementById('floatSpeed');

        // reveal text function (letra a letra) - preserve spaces correctly
        function revealText(element, perChar = 30, startDelay = 200) {
            if (!element) return;
            // cancel any previous reveal on this element
            if (element._revealInterval) {
                clearInterval(element._revealInterval);
                element._revealInterval = null;
            }
            const text = (element.textContent || '');
            element.innerHTML = '';
            const chars = [];
            for (const ch of text) {
                const span = document.createElement('span');
                span.className = 'char';
                // preserve spaces as non-breaking spaces so inline-block spans keep word gaps
                span.textContent = (ch === ' ') ? '\u00A0' : ch;
                element.appendChild(span);
                chars.push(span);
            }
            let i = 0;
            const iv = setInterval(() => {
                if (i >= chars.length) {
                    clearInterval(iv);
                    element._revealInterval = null;
                    return;
                }
                const span = chars[i];
                span.style.opacity = '1';
                span.style.transform = 'translateY(0)';
                i++;
            }, perChar);
            element._revealInterval = iv;
            // allow an initial delay before starting
            if (startDelay > 0) {
                // pause the interval until delay passes
                clearInterval(iv);
                element._revealInterval = setTimeout(() => {
                    element._revealInterval = setInterval(() => {
                        if (i >= chars.length) {
                            clearInterval(element._revealInterval);
                            element._revealInterval = null;
                            return;
                        }
                        const span = chars[i];
                        span.style.opacity = '1';
                        span.style.transform = 'translateY(0)';
                        i++;
                    }, perChar);
                }, startDelay);
            }
        }

        function createHeart() {
            const total = 320; // más corazones para una copa más densa
            const baseDelay = parseInt(spawnDelayInput ? spawnDelayInput.value : 100, 10) || 100;
            // calcular dimensiones robustamente: clientWidth/Height o computed style fallback
            let TW = tree.clientWidth;
            let TH = tree.clientHeight;
            if (!TW || !TH) {
                const cs = getComputedStyle(tree);
                TW = parseFloat(cs.width) || 420;
                TH = parseFloat(cs.height) || 560;
            }
            const centerX = TW / 2;
            const centerY = TH / 2;
            console.log('createHeart() container size', TW, TH, 'baseDelay', baseDelay);
            for (let i = 0; i < total; i++) {
                setTimeout(() => {
                    const heart = document.createElement('div');
                    heart.innerHTML = '❤';
                    heart.className = 'heart';

                    // Posiciones aleatorias para formar la copa del árbol (forma de corazón)
                    const t = Math.random() * Math.PI * 2;
                    const r = Math.random() * (Math.min(TW, TH) / 3); // escala relativa al contenedor
                    // polar to cartesian with a bias to create heart-like cluster
                    let x = centerX + (r * Math.sin(t) * (1 + 0.6 * Math.sin(3 * t)));
                    let y = centerY + (r * Math.cos(t) * (1 + 0.4 * Math.cos(2 * t)));

                    // jitter
                    x += (Math.random() - 0.5) * (TW * 0.08);
                    y += (Math.random() - 0.5) * (TH * 0.08);

                    // asegurar dentro de caja
                    const left = Math.max(0, Math.min(TW - 20, x));
                    const bottom = Math.max(0, Math.min(TH - 20, TH - y));

                    heart.style.left = left + 'px';
                    heart.style.bottom = bottom + 'px';
                    heart.style.color = heartColors[Math.floor(Math.random() * heartColors.length)];
                    heart.style.fontSize = (Math.random() * 20 + 10) + 'px';

                    // controlar duración del float con control
                    const floatSec = (floatSpeedInput ? floatSpeedInput.value : 4);
                    const dur = (parseFloat(floatSec) + (Math.random() - 0.5) * 1.5).toFixed(2);
                    heart.style.animationDuration = `1s, ${dur}s`;

                    tree.appendChild(heart);
                }, i * baseDelay);
            }
        }

        // Añadir más corazones alrededor del tronco (base)
        function createTrunkHearts() {
            const trunkCount = 120; // más corazones en la zona del tronco
            // calcular referencia al centro del contenedor
            let TW = tree.clientWidth || 420;
            let TH = tree.clientHeight || 560;
            if (!TW || !TH) { const cs = getComputedStyle(tree); TW = parseFloat(cs.width)||TW||420; TH = parseFloat(cs.height)||TH||560; }
            const centerX = TW / 2;
            // colocar corazones cerca de la base (y bajo la mitad)
            for (let i = 0; i < trunkCount; i++) {
                setTimeout(() => {
                    const h = document.createElement('div');
                    h.className = 'heart';
                    h.innerHTML = '❤';
                    // posición cerca del tronco (centro) con un pequeño desplazamiento
                    const x = centerX + (Math.random() - 0.5) * 40; // ±20px
                    const bottom = Math.random() * 80; // dentro de 0..80px desde la base
                    h.style.left = Math.max(0, Math.min(TW - 20, x)) + 'px';
                    h.style.bottom = bottom + 'px';
                    h.style.fontSize = (Math.random() * 14 + 8) + 'px';
                    h.style.color = heartColors[Math.floor(Math.random() * heartColors.length)];
                    // suavizar float duration
                    const floatSec = (floatSpeedInput ? floatSpeedInput.value : 4);
                    const dur = (parseFloat(floatSec) + (Math.random() - 0.5) * 1.2).toFixed(2);
                    h.style.animationDuration = `1s, ${dur}s`;
                    tree.appendChild(h);
                }, i * (spawnDelayInput ? parseInt(spawnDelayInput.value,10) : 100));
            }
        }

        // --- AUDIO DE FONDO ---
        const bgAudio = document.getElementById('bg-music');

        // Intento de reproducción sin interacción:
        // 1) Intentar play() con sonido directamente.
        // 2) Si falla, reproducir en mute (la mayoría de navegadores permiten autoplay si está muteado).
        // 3) Tras una pequeña espera, intentar gradualmente subir el volumen y desmutear (best-effort).
        async function tryPlayBackground() {
            if (!bgAudio) return;
            bgAudio.loop = true;
            const targetVolume = 0.6;
            const rampDuration = 4000; // ms para subir el volumen

            // Helper: gradualmente ajustar volumen desde current hasta target
            function rampVolume(to, duration) {
                const from = bgAudio.volume;
                const steps = 30;
                const stepTime = Math.max(10, Math.floor(duration / steps));
                let step = 0;
                const iv = setInterval(() => {
                    step++;
                    const t = step / steps;
                    bgAudio.volume = from + (to - from) * t;
                    if (step >= steps) clearInterval(iv);
                }, stepTime);
            }

            try {
                bgAudio.muted = false;
                bgAudio.volume = targetVolume;
                const p = bgAudio.play();
                if (p && p instanceof Promise) await p;
                console.log('Música de fondo iniciada con sonido');
                return;
            } catch (err) {
                console.warn('Autoplay con sonido bloqueado, intentando reproducir en mute:', err);
            }

            // reproducir en mute (si autoplay con sonido fue bloqueado)
            try {
                bgAudio.muted = true;
                bgAudio.volume = 0;
                const p2 = bgAudio.play();
                if (p2 && p2 instanceof Promise) await p2;
                console.log('Reproducción en mute iniciada (autoplay permitido en mute).');

                // después de un pequeño retardo, intentar desmutear gradualmente
                setTimeout(async () => {
                    try {
                        // Desmutear y subir volumen gradualmente (best-effort). Algunos navegadores
                        // aún pueden bloquear el cambio a sonido real; por eso lo hacemos en try/catch.
                        bgAudio.muted = false;
                        rampVolume(targetVolume, rampDuration);
                        console.log('Intentando subir volumen tras autoplay en mute');
                    } catch (e) {
                        console.warn('No fue posible desmutear automáticamente:', e);
                        // dejar en mute si no es posible
                        bgAudio.muted = true;
                    }
                }, 800);

                return;
            } catch (err) {
                console.warn('No se pudo iniciar reproducción (incluso en mute):', err);
            }
        }

        window.onload = () => {
            updateTimer();

            // intentar iniciar la música de fondo; si el navegador bloquea el autoplay,
            // se mostrará un overlay con un botón para que el usuario la active.
            tryPlayBackground();

            // revelar texto letra a letra
            revealText(document.querySelector('h2') || document.querySelector('h1'), 40, 200);
            revealText(document.getElementById('phrase1'), 18, 600);
            revealText(document.getElementById('phrase2'), 18, 1200);

            // Esperar un frame para asegurar layout aplicado, luego crear corazones
            requestAnimationFrame(() => setTimeout(() => {
                createHeart();
                createTrunkHearts();
            }, 600));
        };
    </script>
</body>
</html>